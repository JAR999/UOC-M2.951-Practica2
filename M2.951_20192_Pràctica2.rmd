---
title: "M2.951_20192_Pràctica2"
author: "Oriol Calvo i Josep Adrian"
date: "Maig-Juny 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1. Descripció del dataset. 
## Perquè és important i quina pregunta/problema pretén respondre?

Escollim el dataset "Beijing Multiset Air Quality" de UC Irvine Machine Learning Repository https://archive.ics.uci.edu/ml/datasets/Beijing+Multi-Site+Air-Quality+Data 

This data set includes hourly air pollutants data from 12 nationally-controlled air-quality monitoring sites. The air-quality data are from the Beijing Municipal Environmental Monitoring Center. The meteorological data in each air-quality site are matched with the nearest weather station from the China Meteorological Administration. The time period is from March 1st, 2013 to February 28th, 2017. Missing data are denoted as NA.


# 2. Integració i selecció de les dades d’interès a analitzar.

## Càrrega fitxer
Carreguem el fitxer i en mostrem estadístics bàsics

```{r}
rm(list=ls())

ruta="C:/Users/JADRIANR/OneDrive - Cellnex Telecom/PROJECTES/Other/UOC/Q3/Cicle Vida dades/Practica 2/PRSA_Data_20130301-20170228/"

fitxers=list.files(ruta)

dades<-read.csv(paste(ruta,fitxers[1],sep=""), header=T, sep=",")

for (i in 2:length(fitxers)) {
  dades_i<-read.csv(paste(ruta,fitxers[i],sep=""), header=T, sep=",")
  dades=rbind(dades,dades_i)
}
rm(dades_i,i,fitxers,ruta)

#summary(dades)
```

## Preparació de les dades
A continuació discretitzarem algunes de les dades del conjunt, que es presenten originalment de forma contínua. La discretització ens ajudara a treballar millor amb les dades i a explicar-les millor de manera que els resultats siguin més rellevants i entenedors.

Primerament observem el dataset per veure quins valors poden ser discretitzats.

```{r}
apply(dades,2, function(x) length(unique(x)))

```

Discretitzem les variables amb menys classes, que funcionalment representen variables categòriques (dies, hores, direcció del vent...).

```{r}
dades$year=as.factor(dades$year)
dades$month=as.factor(dades$month)
dades$day=as.factor(dades$day)
dades$hour=as.factor(dades$hour)
dades$wd=as.factor(dades$wd)
dades$station=as.factor(dades$station)
```

## Creació de nous atributs
Creem noves variables

- RAIN_BOOL, que indica si plovia en aquella medició
- WIND, que indica si feia vent en aquella medició
- Direccio, que indica la direcció del vent en graus
- Data_Cal, amb la data de la observació creada a partir de dia-mes-any.
- Estacio_any: Hivern, Primavera, Estiu o Tardor, segons el mes

```{r}
dades$RAIN_BOOL<-"Pluja"
dades$RAIN_BOOL[dades$RAIN==0]<-"Sense pluja"
dades$RAIN_BOOL<-as.factor(dades$RAIN_BOOL)

dades$WIND<-"Vent"
dades$WIND[dades$WSPM<1]<-"Sense vent"
dades$WIND<-as.factor(dades$WIND)

dades$direccio[dades$wd=="N"]<-0
dades$direccio[dades$wd=="NNE"]<-22.5
dades$direccio[dades$wd=="NE"]<-45
dades$direccio[dades$wd=="ENE"]<-67.5
dades$direccio[dades$wd=="E"]<-90
dades$direccio[dades$wd=="ESE"]<-112.5
dades$direccio[dades$wd=="SE"]<-135
dades$direccio[dades$wd=="SSE"]<-157.5
dades$direccio[dades$wd=="S"]<-180
dades$direccio[dades$wd=="SSW"]<-202.5
dades$direccio[dades$wd=="SW"]<-225
dades$direccio[dades$wd=="WSW"]<-247.5
dades$direccio[dades$wd=="W"]<-270
dades$direccio[dades$wd=="WNW"]<-292.5
dades$direccio[dades$wd=="NW"]<-315
dades$direccio[dades$wd=="NNW"]<-337.5
dades$direccio=as.factor(dades$direccio)

dades$Data_Cal=as.Date(paste(dades$year,"-",dades$month,"-",dades$day,sep=""))

dades$estacio_any[dades$month==1 |dades$month==2|dades$month==3]<-"Hivern"
dades$estacio_any[dades$month==4 |dades$month==5|dades$month==6]<-"Primavera"
dades$estacio_any[dades$month==7 |dades$month==8|dades$month==9]<-"Estiu"
dades$estacio_any[dades$month==10 |dades$month==11|dades$month==12]<-"Tardor"
dades$estacio_any=as.factor(dades$estacio_any)

```

## Estadística descriptiva
Explorem gràficament les dades per a mirar de detectar patrons de conducta.

```{r}
#install.packages('ggplot2', repos='http://cran.us.r-project.org')
library(ggplot2)
library(gridExtra)

p1<-ggplot(dades,aes(x=year,fill=direccio))+geom_bar(position="fill")
p2<-ggplot(dades,aes(x=month,fill=direccio))+geom_bar(position="fill")
p3<-ggplot(dades,aes(x=day,fill=direccio))+geom_bar(position="fill")
p4<-ggplot(dades,aes(x=hour,fill=direccio))+geom_bar(position="fill")

grid.arrange(p1, p2, p3, p4, ncol=2)

# ggplot(dades,aes(x=year,fill=station))+geom_bar(position="fill")
# ggplot(dades,aes(x=month,fill=station))+geom_bar(position="fill")
# ggplot(dades,aes(x=day,fill=station))+geom_bar(position="fill")
# ggplot(dades,aes(x=hour,fill=station))+geom_bar(position="fill")

p1<-ggplot(dades,aes(x=year,fill=RAIN_BOOL))+geom_bar(position="fill")
p2<-ggplot(dades,aes(x=month,fill=RAIN_BOOL))+geom_bar(position="fill")
p3<-ggplot(dades,aes(x=day,fill=RAIN_BOOL))+geom_bar(position="fill")
p4<-ggplot(dades,aes(x=hour,fill=RAIN_BOOL))+geom_bar(position="fill")

grid.arrange(p1, p2, p3, p4, ncol=2)

p1<-ggplot(dades,aes(x=year,fill=WIND))+geom_bar(position="fill")
p2<-ggplot(dades,aes(x=month,fill=WIND))+geom_bar(position="fill")
p3<-ggplot(dades,aes(x=day,fill=WIND))+geom_bar(position="fill")
p4<-ggplot(dades,aes(x=hour,fill=WIND))+geom_bar(position="fill")

grid.arrange(p1, p2, p3, p4, ncol=2)

par(mfrow=c(2,2))

p1<-boxplot(dades$TEMP~dades$year)
p2<-boxplot(dades$TEMP~dades$month)
p3<-boxplot(dades$TEMP~dades$day)
p4<-boxplot(dades$TEMP~dades$hour)

par(mfrow=c(2,2))
p1<-boxplot(dades$PM10~dades$year)
p2<-boxplot(dades$PM10~dades$month)
p3<-boxplot(dades$PM10~dades$day)
p4<-boxplot(dades$PM10~dades$hour)

par(mfrow=c(2,2))
p1<-boxplot(dades$CO~dades$year)
p2<-boxplot(dades$CO~dades$month)
p3<-boxplot(dades$CO~dades$day)
p4<-boxplot(dades$CO~dades$hour)

par(mfrow=c(2,2))
p1<-boxplot(dades$RAIN~dades$year)
p2<-boxplot(dades$RAIN~dades$month)
p3<-boxplot(dades$RAIN~dades$day)
p4<-boxplot(dades$RAIN~dades$hour)

rm(p1,p2,p3,p4)

#PENDENT: Millorar aspecte gràfics (llegenda única, colors...)
```

Observem diversos patrons com:

- El vent bufa generalment del sud i de l'oest a la tarda, mentre que als matins ho fa generalment del nord i l'est
- El vent bufa generalment més durant el dia que no pas durant la nit
- L'època de precipitacions més forta es dóna en els mesos d'estiu
- La temperatura és també més alta en els mesos d'estiu


## Estudis de la qualitat de l'aire 

Observarem la qualiat de l'aire de les mesures a partir de les dades dels indicadors. Segons els estàndards de la qualitat de l'aire https://ec.europa.eu/environment/air/quality/standards.htm els nivells no haurien de superar 

* PM2.5 > 25ug/m3 en mitjana anual
* PM10 > 50ug/m3 en mitjana diaria + 40ug/m3 en mitjana anual

```{r}
library(zoo)
library(ggplot2)

#Omitim valors nuls per a calcular la mitja mòbil
dades2=na.omit(dades)

#Calculem la mitja mòbil anual i diària, pels indicadors seleccionats
Pm2.5_year=(rollapply(dades2$PM2.5,365*24,mean))
Pm10_year=(rollapply(dades2$PM10,365*24,mean))
Pm10_day=(rollapply(dades2$PM10,24,mean))

# plot(Pm2.5_year,type="l",col="red")
# lines(l25,col="green")
# 
# plot(Pm10_year,type="l",col="red")
# lines(l40,col="green")
# 
# plot(Pm10_day,type="l",col="red")
# lines(l50,col="green")

# dades_diaries=data.frame(x=1:length(Pm10_day),Pm10_day)
# dades_anuals=data.frame(x=1:length(Pm2.5_year),Pm2.5_year,Pm10_year)

#Obtenim els valors corresponents de les dates de la mitja mòbil
dates_anys=dades2$Data_Cal[(365*24):nrow(dades2)]
dates_dies=dades2$Data_Cal[24:nrow(dades2)]

#Creem 2 datasets per guardar les mitges mòbils diàries i anuals
dades_anuals_mm=data.frame(data=dates_anys,Pm2.5_year,Pm10_year)
dades_diaries_mm=data.frame(data=dates_dies,Pm10_day)
# dades_anuals$year=as.factor(dades_anuals$year)
# dades_diaries$year=as.factor(dades_diaries$year)

#Dibuixem les dades amb la línia de referència de cada mesura
p<-ggplot(data=dades_diaries_mm,aes(x=data,y=Pm10_day)) + geom_line() 
p+geom_hline(yintercept=50)

p<-ggplot(data=dades_anuals_mm,aes(x=data,y=Pm10_year)) + geom_line() 
p+geom_hline(yintercept=40)

p<-ggplot(data=dades_anuals_mm,aes(x=data,y=Pm2.5_year)) + geom_line() 
p+geom_hline(yintercept=25)

rm(p,Pm2.5_year,Pm10_year,Pm10_day,dades_anuals_mm,dades_diaries_mm,dates_anys,dates_dies)

#PENDENT: Millorar aspecte gràfics (colors, llegenda, grid...)

```

Observem que les dades mitjanes per any i per dia estan molt per sobre de les recomanades per les autoritats mediambientals.

## Estudis efectes principals i interaccions

A continuació estudiarem els efectes principals i les interaccions entre algunes de les variables que observem gràficament que son importants per a l'estudi

### Efecte de la direcció del vent en PM10 segons la pluja

```{r}
library(dplyr)
taula_resum=summarise_at(group_by(dades2,direccio,RAIN_BOOL),vars(PM10),list(mean))

ggplot(taula_resum, aes(x = direccio, y = PM10, fill = RAIN_BOOL)) + 
    stat_summary(aes(group = RAIN_BOOL, color = RAIN_BOOL), fun = "mean", geom = "line", 
                 position = position_dodge(.2), size = 1) + 
    labs(title = "Efecte de la direcció del vent en la quantitat de partícules segons pluja", 
         x = "Direcció del vent", y = "PM10") + 
    theme_bw(base_size = 12) + 
    theme(panel.grid.major.x = element_blank(),
          axis.ticks.x = element_blank())
```

El gràfic resultant ens permet interpretar que la direcció del vent té efecte sobre la concentració de PM10 (ja que les línies no son horitzontals) i que la pluja també en té (ja que les línies no se superposen). Adicionalment als efectes principals, el gràfic ens permet afirmar que les variables presenten interacció entre elles, ja que les línies no son paral·leles. Clarament, quan plou, la direcció del vent no és tan important per determinar la concentració de partícules.

### Efecte de la direcció del vent en PM10 segons l'estació de l'any

Repetim l'estudi segons l'estació de l'any.

```{r}
taula_resum=summarise_at(group_by(dades2,direccio,estacio_any),vars(PM10),list(mean))

ggplot(taula_resum, aes(x = direccio, y = PM10, fill = estacio_any)) + 
    stat_summary(aes(group = estacio_any, color = estacio_any), fun = "mean", geom = "line", 
                 position = position_dodge(.2), size = 1) + 
    labs(title = "Efecte de la direcció del vent en la quantitat de partícules segons estació any", 
         x = "Direcció del vent", y = "PM10") + 
    theme_bw(base_size = 12) + 
    theme(panel.grid.major.x = element_blank(),
          axis.ticks.x = element_blank())

rm(taula_resum)

```
El gràfic resultant ens confirma la dependència de la quantitat de partícules segons la direcció del vent així com de l'estació de l'any. Adicionalment el gràfic ens permet afirmar que les variables no presenten interacció entre elles, ja que les línies guarden un cert paral·lelisme.

# 3. Neteja de les dades.
## 3.1. Les dades contenen zeros o elements buits? Com gestionaries aquests casos?

Localització dels valors perduts
```{r}
valors_perduts=colSums(is.na(dades))
valors_perduts
```


Eliminem els valors perduts?

```{r}
dades2=na.omit(dades)

```

Enlloc d'eliminar els valors perduts, els imputem amb la funció k-nearest neighbours.

Agrupem les dades perdudes per estació i per mes. Observem que estan aproximadament distribuïdes per totes les categories.

```{r}
#Exemple valors perduts per PM10
dades_perdudes_PM10=subset(dades,is.na(dades$PM10))

barplot(tapply(dades_perdudes_PM10$PM10,dades_perdudes_PM10$station,length),las=2,xlab = "Estació",ylab="Total valors perduts",main="Valors perduts PM10 per estació")
barplot(tapply(dades_perdudes_PM10$PM10,dades_perdudes_PM10$hour,length),xlab = "Mes",ylab="Total valors perduts",main="Valors perduts PM10 per hora")

rm(dades_perdudes_PM10)

```

Estimació valors perduts per kNN. Imputem amb dades de la mateixa hora i estació.

```{r}
#boxplot(dades$PM10~dades$station)
#boxplot(dades$PM10~dades$hour)

library(VIM)
library(dplyr)

stations=unique(dades$station)
hours=unique(dades$hour)
total_station=length(stations)
total_hour=length(hours)

#Calcul molt costós a partir d'estació i hora (es pot mantenir?)

# for (i in 1:total_station){
#   for(j in 1:total_hour){
#     subset=subset(dades,dades$station==stations[i] & dades$hour==hours[j])
#     dades_imp_ij=kNN(subset,k=3)
#     dades$PM10[dades$station==stations[i] & dades$hour==hours[j]]=dades_imp_ij$PM10
#   }
# }

#Càlcul més lleuger. Només a partir de l'estació amb mostreig del 10%
dades_sample=sample_frac(dades,0.1)

for (i in 1:total_station){
    subset=subset(dades_sample,dades_sample$station==stations[i])
    dades_imp_i=kNN(subset,k=3)
    dades_sample$PM10[dades_sample$station==stations[i]]=dades_imp_i$PM10
}

#Observem que no queden valors perduts després de la imputació
colSums(is.na(dades_sample))

rm(hours,i,stations,total_hour,total_station,subset,dades_imp_i)
```


## 3.2. Identificació i tractament de valors extrems.

Identifiquem els valors extrems de les variables i...

```{r}
#PENDENT: Quin tractament es fa als valors extrems??

remove_outliers <- function(x, na.rm = TRUE, ...) {
  qnt <- quantile(x, probs=c(.25, .75), na.rm = na.rm, ...)
  H <- 1.5 * IQR(x, na.rm = na.rm)
  y <- x
  y[x < (qnt[1] - H)] <- NA
  y[x > (qnt[2] + H)] <- NA
  y
}

dades3=dades
dades3$SO2<-remove_outliers(dades$SO2)
dades3=na.omit(dades3)

boxplot(dades$SO2)
boxplot(dades3$SO2)

```

# 4. Anàlisi de les dades.

## 4.1. Selecció dels grups de dades que es volen analitzar/comparar (planificació dels anàlisis a aplicar).

PENDENT: Eliminem les dades dels anys 2013 i 2017 que presenten valors imcomplets??

```{r}
dades4=subset(dades,dades$year!=2017)
dades4=subset(dades,dades$year!=2013)
```

Mostreig de dades per a facilitar l'anàlisis. Agafem un 10% del conjunt original per tal de facilitar els càlculs i les visualitzacions de dades.

```{r}

dades5=sample_frac(dades,0.1)
```

## 4.2. Comprovació de la normalitat i homogeneïtat de la variància.

### Comprovació normalitat
Comprovem gràficament la normalitat de les variables. Observem que no segueixen una distribució normal.

```{r}
par(mfrow=c(2,2))
hist(dades$PM10,xlab="PM10",freq=FALSE,main=NULL)
curve(dnorm(x,mean=mean(dades$PM10),sd=sd(dades$PM10)), add=TRUE,col="red")

hist(dades$PM2.5,xlab="PM2.5",freq=FALSE,main=NULL)
curve(dnorm(x,mean=mean(dades$PM2.5),sd=sd(dades$PM2.5)), add=TRUE,col="red")

hist(dades$TEMP,xlab="Temperatura",freq=FALSE,main=NULL)
curve(dnorm(x,mean=mean(dades$TEMP),sd=sd(dades$TEMP)), add=TRUE,col="red")

hist(dades$WSPM,xlab="Velocitat del vent",freq=FALSE,main=NULL)
curve(dnorm(x,mean=mean(dades$WSPM),sd=sd(dades$WSPM)), add=TRUE,col="red")

```

Mostrem també un gràfic quantil-quantil per ratificar les observacions anteriors. Observem com els valors extrems de la part superior se surten de la distribució normal.

```{r}
#Seleccionem "PM10","PM2.5","TEMP","WSPM"
library("ggpubr")

var = c(7,6,12,17)

par(mfrow=c(2,2))
for (i in 1:4)
{
qqnorm(dades[,var[i]], pch = 1, frame = FALSE)
qqline(dades[,var[i]], col = "steelblue", lwd = 2)
}

# par(mfrow=c(2,2))
# for (i in 1:4)
# {
# ggqqplot(dades[,var[i]])
# }
# 

```

Efectuarem addicionalment el test Anderson-Darling normalitat per a les variables seleccionades. 

```{r}
library(nortest)
ad.test(dades$PM2.5)
ad.test(dades$PM10)
ad.test(dades$TEMP)
ad.test(dades$WSPM)
```
Observem que el p-valor en tots els casos és inferior a 0.01 per la qual cosa confirmem la hipòtesis de no-normalitat de les dades.

### Comprovació homogeneitat variables

Utilitzarem el test de Fligner-Killeen ja que és el més adequat en distribucions no normals com l'actual.

```{r}
fligner.test(PM10 ~ PM2.5, data = dades)
fligner.test(PM10 ~ CO, data = dades)
fligner.test(PM10 ~ TEMP , data = dades)
```

Observem que el conjunt no compleix la hipòtesis d'homogeneitat de variables.

## 4.3. Aplicació de proves estadístiques per comparar els grups de dades. En funció de les dades i de l’objectiu de l’estudi, aplicar proves de contrast d’hipòtesis, correlacions, regressions, etc. Aplicar almenys tres mètodes d’anàlisi diferents.

### a) Estimació d'un model lineal per a la variable PM10

En aquest exercici estimarem un model lineal per tal de calcular la variable X a partir de la resta de variables quantitatives del dataset

Primerament creem un subconjunt amb les variables que utilitzarem en el model.

```{r}
dades6=subset(dades2,select = c(PM2.5,PM10,SO2,NO2,CO,O3,TEMP,PRES,DEWP,RAIN,WSPM))

library(corrplot)
```

Obtenim una matriu de correlació de les variables del conjunt.

```{r}
corrplot(cor(dades6), type = "upper", order = "hclust", tl.col = "black", tl.srt = 45, sig.level = 0.1, insig = "blank")

library("PerformanceAnalytics")

#Pendent descomentar: Molt costós en temps
#chart.Correlation(dades6)
```
Observem que hi ha diversos parells de variables que mostren una correlació significativa. Exemples....

Construïm un model lineal per estimar PM10 a partir de les altres variables. Primerament seleccionem un subset de test amb 2/3 de les dades.???

```{r}
set.seed(111)
mida_conjunt=2/3
indexes = sample(1:nrow(dades6), size=floor(mida_conjunt*nrow(dades6)))

train<-dades6[indexes,]
test<-dades6[-indexes,]
```


```{r}
model_lm1 <- lm(PM10~PM2.5+SO2+NO2+CO+O3+TEMP+PRES+DEWP+RAIN+WSPM, data = train,model=TRUE)
summary(model_lm1)
```

Observem que les variables... son significatives per al model de correlació

#### Predicció de les dades

PENDENT: Com es prediuen les dades? Com s'estima la qualitat del model?

```{r}

```
### b) Contrast d'hipòtesis

Volem esbrinar si alguna de les estacions té uns índexs de partícules significativament més gran que les altres

Obtenim la mitjana de totes les observacions, per estació meteorològica

```{r}

mitjana_estacio=tapply(dades2$PM10,dades2$station,mean)
sort(mitjana_estacio)

barplot(sort(mitjana_estacio),las=2)

```

Observem que l'estació amb una mitjana més alta és la de Gucheng i la més baixa és la de Dingling. A continuació obtindrem un interval de confiança per la mitjana de les dades en tota la població.

```{r}
interval_conf<-function(vector,nivell_conf) {
mitjana=mean(vector)
sd=sd(vector)
n=length(vector)
qt=qt((1+nivell_conf)/2,df=n-1)
error=sd*qt/sqrt(n)
i_conf<-c(mitjana-error,mitjana+error)
return(i_conf)
}

interval_conf(dades2$PM10[dades$station=="Dingling"],0.99)
interval_conf(dades2$PM10[dades$station=="Gucheng"],0.99)
```

En vista dels resultats, podem afirmar amb un 99% de confiança que la mitjana de concentració de partícules de PM10 de l'estació X son majors que les de Y. 

Mostrem gràficament els intervals de confinçar per a la mitjana de cada una de les estacions.

```{r}
#PENDENT:Millorar gràfics (llegendes, colors...)
stations=unique(dades$station)
total_station=length(stations)

intervals=matrix(nrow=4,ncol=12)
 for (i in 1:total_station){
   intervals[1,i]=stations[i]
   intervals[2,i]=mean(dades2$PM10[dades2$station==stations[i]])
   intervals[3,i]=interval_conf(dades2$PM10[dades2$station==stations[i]],0.99)[1]
   intervals[4,i]=interval_conf(dades2$PM10[dades2$station==stations[i]],0.99)[2]   
 } 
#install.packages("plotrix")
library(plotrix)
plotCI(intervals[1,],y=intervals[2,],uiw=intervals[4,]-intervals[2,],liw=intervals[2,]-intervals[3,])

rm(intervals)
```
Observem que alguns intervals de confiança intersequen, cosa qe indica que no es pot afirmar que la mitjana de PM10 sigui major o menor que la de l'altre.

Repetim l'anàlisi per estacions per la variable CO.

```{r}
interval_conf(dades2$CO[dades2$estacio_any=="Hivern"],0.99)
interval_conf(dades2$CO[dades2$estacio_any=="Primavera"],0.99)
interval_conf(dades2$CO[dades2$estacio_any=="Estiu"],0.99)
interval_conf(dades2$CO[dades2$estacio_any=="Tardor"],0.99)
```
Observem que amb un 99% de confiança, la mitjana de CO durant la tardor és superior a la de l'hivern i aquesta superior a la de primavera i estiu. No obstant això, no es pot afirmar que la d'estiu sigui superior a la de primavera ja que els intervals se superposen.

Repetim la representació gràfica

```{r}
#PENDENT:Millorar gràfics
estacions=unique(dades2$estacio_any)
total_estacions=length(estacions)

intervals=matrix(nrow=4,ncol=4)
 for (i in 1:total_estacions){
   intervals[1,i]=estacions[i]
   intervals[2,i]=mean(dades2$CO[dades2$estacio_any==estacions[i]])
   intervals[3,i]=interval_conf(dades2$CO[dades2$estacio_any==estacions[i]],0.99)[1]
   intervals[4,i]=interval_conf(dades2$CO[dades2$estacio_any==estacions[i]],0.99)[2]   
 } 

plotCI(intervals[1,],y=intervals[2,],uiw=intervals[4,]-intervals[2,],liw=intervals[2,]-intervals[3,])

rm(intervals)

```


### c) TERCERA PROVA ESTADÍSTICA

?????


# 5. Representació dels resultats a partir de taules i gràfiques.

# 6. Resolució del problema. A partir dels resultats obtinguts, quines són les conclusions? Els resultats permeten respondre al problema?

# 7. Codi: Cal adjuntar el codi, preferiblement en R, amb el que s’ha realitzat la neteja, anàlisi i representació de les dades. Si ho preferiu, també podeu treballar en Python.
